#!/usr/bin/python
# -*- coding: Latin1 -*-
# Programmé par Jérome Kieffer : kieffer@terre-adelie.org
# Conception : Jérôme KIEFFER et  Mickael Profeta
# Avec la participation de Isabelle Letard
# version 0.3 : 28/10/2004
# version 0.4 : 28/10/2004
# version 1.1 : 11/01/2005
# Liste des dépendances : python, PIL, Glade-2
# Exiftran existe en version windows maintenant ... nous utilisons une verison modifiée ...!!!!
#
#todo liste des fonctions a implemanter ....
# faire une doc décente.
# 
#Licence : GPL version 2
#
# cette version comprend l'autowarning ainsi que toutes les fonctions de navigation.
# reste a implemanter
# - la version windows
# - le fichier de preference
# - la modification des preferences
# - la creation de splash-sceens 


import pygtk ; pygtk.require('2.0')
import os,sys,string,Image,shutil,time,re,gtk,gtk.glade,gc




ThumbSize=160
ScreenSize=600
ScaledSize=800
NbrPerPage=20
PagePrefix="page"
Trash="Trash"
Selected="Selected"
Selected_save=".selected-photos"
Exts=[".jpg", ".jpeg"]
scaled="scaled"
thumb="thumb"
autorotate=False
DefaultMode="664"

	
Interpolation=gtk.gdk.INTERP_TILES
#gtk.gdk.INTERP_NEAREST	Nearest neighbor sampling; this is the fastest and lowest quality mode. Quality is normally unacceptable when scaling down, but may be OK when scaling up.
#gtk.gdk.INTERP_TILES	This is an accurate simulation of the PostScript image operator without any interpolation enabled. Each pixel is rendered as a tiny parallelogram of solid color, the edges of which are implemented with antialiasing. It resembles nearest neighbor for enlargement, and bilinear for reduction.
#gtk.gdk.INTERP_BILINEAR	Best quality/speed balance; use this mode by default. Bilinear interpolation. For enlargement, it is equivalent to point-sampling the ideal bilinear-interpolated image. For reduction, it is equivalent to laying down small tiles and integrating over the coverage area.
#gtk.gdk.INTERP_HYPER	This is the slowest and highest quality reconstruction function. It is derived from the hyperbolic filters in Wolberg's "Digital Image Warping", and is formally defined as the hyperbolic-filter sampling the ideal hyperbolic-filter interpolated image (the filter is designed to be idempotent for 1:1 pixel mapping).

clef={
'Image Make': 'Marque',
'Image Model': 'Modele',
'Image DateTime': 'Heure',
'EXIF Flash':'Flash',
'EXIF FocalLength': 'Focale',
'EXIF FNumber': 'Ouverture',
'EXIF ExposureTime' :'Vitesse',
'EXIF ISOSpeedRatings': 'Iso',
'EXIF ExposureBiasValue': 'Bias'}

#here we detect the OS runnng the program so that we can call exftran in the right way
if os.name == 'nt': #sys.platform == 'win32':
	installdir="c:\\Imagizer"
	exiftran=os.path.join(installdir,"exiftran.exe ")
	gimpexe="gimp-remote "
elif os.name == 'posix':
	installdir='/usr/share/imagizer'
	exiftran=os.path.join(installdir,"exiftran ")
	gimpexe="gimp-remote "
else:
	raise "Your platform does  not seem to be an Unix nor a M$ Windows.\nI am sorry but the exiftran binary is necessary to run selector, and exiftran is probably not available for you plateform. If you have exiftran installed, please contact the developper to correct that bug, kieffer at terre-adelie dot org"
	sys.exit(1)

sys.path.append(installdir)	
interfaceglade=os.path.join(installdir,"interface.glade")
interfaceSplash=os.path.join(installdir,"splash.glade")
interfaceWarning=os.path.join(installdir,"warning.glade")
interfacefiler=os.path.join(installdir,"filer.glade")
import EXIF











#default mode  is in octal ... here we convert octal -> decimal
DefaultFileMode=0
for i in list(DefaultMode):
	DefaultFileMode*=8
	DefaultFileMode+=int(i)

DefaultDirMode=DefaultFileMode+3145 #73 = +111 en octal ... 3145 +s mode octal



class photo:
	"""class photo that does all the operations available on photos"""
	def __init__(self,filename):
		self.filename=filename
		self.fn=os.path.join(curdir,self.filename)
		if not os.path.isfile(self.fn): print "Erreur, le fichier %s n'existe pas"%self.fn 

	def LoadPIL(self):
		"""Load the image"""
		self.f=Image.open(self.fn)
	
	def larg(self):
		"""width-height of a jpeg file"""
		x,y=self.taille()
		return x-y

	def taille(self):
		"""width and height of a jpeg file"""
		self.LoadPIL()
		self.x,self.y=self.f.size
		return self.x,self.y	

	def SaveThumb(self,thumbname,size=160,Quality=1,AllowExif=True):
		"""save a thumbnail of the given name, with the given size and the interpollation mathode (quality) 
		resampling filters :
		NONE = 0
		NEAREST = 0
		ANTIALIAS = 1 # 3-lobed lanczos
		LINEAR = BILINEAR = 2
		CUBIC = BICUBIC = 3
		"""
		if  os.path.isfile(thumbname):
			print "sorry, file %s exists"%thumbname
		else:
			RawExif,comment=EXIF.process_file(open(self.fn,'rb'),0)
			if RawExif.has_key("JPEGThumbnail") and AllowExif:
				w=open(thumbname,"wb")
				w.write(RawExif["JPEGThumbnail"])
				w.close()			
			else:
				self.LoadPIL()
				self.f.thumbnail((size,size),Quality)
				self.f.save(thumbname)
			os.chmod(thumbname,DefaultFileMode)

	
	def Rotate(self,angle=0):
		"""does a looseless rotation of the given jpeg file"""
                if os.name == 'nt' and self.f!=None: del self.f
             
		if angle==90:
			os.system(exiftran+' -ip -9 "%s"'%self.fn)	
		elif angle==270:
			os.system(exiftran+' -ip -2 "%s"'%self.fn)
		elif angle==180:
			os.system(exiftran+' -ip -1 "%s"'%self.fn)	
		else:
			print "Erreur ! il n'est pas possible de faire une rotation de ce type sans perte de donnée."
	

	def Trash(self):
		"""Send the file to the trash folder"""	
		td=os.path.dirname(os.path.join(Trashdir,self.filename))
		tf=os.path.join(Trashdir,self.filename)
		if not os.path.isdir(td): makedir(td)
		shutil.move(self.fn,os.path.join(Trashdir,self.filename))
			
	def exif(self):
		"""return exif data + title from the photo"""
		data={}
		data["Taille"]="%s ko"%(os.path.getsize(self.fn)/1024)
		
		RawExif,comment=EXIF.process_file(open(self.fn,'rb'),0)
		if comment:
			data["Titre"]=comment
		else:
			data["Titre"]=""
		x,y=self.taille()
		data["Resolution"]="%s x %s "%(x,y)
		for i in clef:
			try:
				data[clef[i]]=str(RawExif[i].printable).strip()
			except:
				data[clef[i]]=""
		return data
		
	def show(self,Xsize=600,Ysize=600):
		"""return a pixbuf to shows the image in a Gtk window"""
		self.x,self.y=self.taille()			
		pixbuf = gtk.gdk.pixbuf_new_from_file(self.fn)
		if self.x>Xsize:
			RX=1.0*Xsize/self.x
		else :
			RX=1
		if self.y>Ysize:
			RY=1.0*Ysize/self.y
		else :
			RY=1	
		R=min(RY,RX)
		if R<1:
			nx=int(R*self.x)
			ny=int(R*self.y)
			scaled_buf=pixbuf.scale_simple(nx,ny,Interpolation)
		else :
			scaled_buf=pixbuf
		return scaled_buf
				
	def name(self,titre):
		"""write the title of the photo inside the description field, in the JPEG header"""	
                if os.name == 'nt' and self.f!=None: del self.f
		os.system(exiftran+' -ipc "%s"  "%s"'%(titre,self.fn))
		
	def autorotate(self):
		"""does autorotate the image according to the EXIF tag"""
		if os.name == 'nt' and self.f!=None: del self.f
		os.system(exiftran+' -aip "%s"'%self.fn)
		
# # # # # # fin de la classe photo # # # # # # # # # # #
class interface:
	"""class interface that manages the GUI using Glade-2"""
	def __init__(self,AllJpegs=[],first=0):
		self.AllJpegs=AllJpegs
		self.Selected=LoadSelected()
		for i in self.Selected:
			if not(i in self.AllJpegs): 
				self.Selected.remove(i)
		self.CurIm=first
		print "Initialisation de l'interface graphique ..."
		self.xml=gtk.glade.XML(interfaceglade)
		self.xml.get_widget("Logo").set_from_pixbuf(gtk.gdk.pixbuf_new_from_file(os.path.join(installdir,"logo.png")))
		self.ShowImage()
		self.xml.signal_connect('on_Principale_destroy',self.destroy)
		self.xml.signal_connect('on_suivant_clicked',self.next)
		self.xml.signal_connect('on_precedant_clicked',self.previous)
		self.xml.signal_connect('on_droite_clicked',self.droite)
		self.xml.signal_connect('on_gauche_clicked',self.gauche)
		self.xml.signal_connect('on_Selection_toggled',self.select)
		self.xml.signal_connect('on_photo_client_event',self.next)
		
		self.xml.signal_connect('on_About_activate',self.about)
		self.xml.signal_connect('on_quitter1_activate',self.die)
		self.xml.signal_connect('on_executer1_activate',self.run)
		self.xml.signal_connect('on_poubelle_activate',self.poubelle)
		self.xml.signal_connect('on_Poubelle_clicked',self.poubelle)
		self.xml.signal_connect('on_Gimp_clicked',self.gimp)
		
		self.xml.signal_connect('on_precedentI_activate',self.previous)
		self.xml.signal_connect('on_suivantI_activate',self.next)
		self.xml.signal_connect('on_premierI_activate',self.first)
		self.xml.signal_connect('on_dernierI_activate',self.last)
		self.xml.signal_connect('on_plus_10_activate',self.next10)
		self.xml.signal_connect('on_moins_10_activate',self.previous10)

		self.xml.signal_connect('on_precedentJ_activate',self.previousJ)
		self.xml.signal_connect('on_suivantJ_activate',self.nextJ)
		self.xml.signal_connect('on_premierJ_activate',self.firstJ)
		self.xml.signal_connect('on_dernierJ_activate',self.lastJ)

		self.xml.signal_connect('on_precedentS_activate',self.previousS)
		self.xml.signal_connect('on_suivantS_activate',self.nextS)
		self.xml.signal_connect('on_premierS_activate',self.firstS)
		self.xml.signal_connect('on_dernierS_activate',self.lastS)

		self.xml.signal_connect('on_precedentNS_activate',self.previousNS)
		self.xml.signal_connect('on_suivantNS_activate',self.nextNS)
		self.xml.signal_connect('on_premierNS_activate',self.firstNS)
		self.xml.signal_connect('on_dernierNS_activate',self.lastNS)

		
		self.xml.signal_connect('on_enregistrerS_activate',self.SaveSelection)
		self.xml.signal_connect('on_chargerS_activate',self.LoadSelection)
		self.xml.signal_connect('on_inverserS_activate',self.InvertSelection)
		self.xml.signal_connect('on_aucun1_activate',self.SelectNone)
		self.xml.signal_connect('on_TouS_activate',self.SelectAll)
		

		gtk.main()

	def settitle(self):
		"""Set the new title of the image"""
	 	newtitle=self.xml.get_widget("Titre").get_text()
		if newtitle!=self.oldtitle:
			self.image.name(newtitle)		


	def ShowImage(self):
		"""Show the image in the given GtkImage widget and set up the exif tags in the GUI"""
		self.image=photo(self.AllJpegs[self.CurIm])
		X,Y=self.xml.get_widget("Principale").get_size()
		if X<325 : X=798
		pixbuf=self.image.show(X-323,Y)
		self.xml.get_widget("photo").set_from_pixbuf(pixbuf)
		del pixbuf
		gc.collect()
		data=self.image.exif()
		for i in data:
			self.xml.get_widget(i).set_text(data[i])
		self.xml.get_widget("Principale").set_title("Selector : %s"%self.AllJpegs[self.CurIm])
		self.xml.get_widget("Selection").set_active((self.AllJpegs[self.CurIm] in self.Selected))
		self.oldtitle=data["Titre"]		

	def next(self,*args):
		"""Switch to the next image"""	
		self.settitle()
		self.CurIm=(self.CurIm+1)%len(self.AllJpegs)
		self.ShowImage()
		
	def next10(self,*args):
		"""Switch forward of 10 images """	
		self.settitle()
		self.CurIm=self.CurIm+10
		if self.CurIm>len(self.AllJpegs):self.CurIm=len(self.AllJpegs)-1
		self.ShowImage()	
		
	def previous(self,*args):
		"""Switch to the previous image"""	
		self.settitle()
		self.CurIm=(self.CurIm-1)%len(self.AllJpegs)
		self.ShowImage()
	
	def previous10(self,*args):
		"""Switch 10 images backward"""	
		self.settitle()
		self.CurIm=self.CurIm-10
		if self.CurIm<0: self.CurIm=0
		self.ShowImage()	
		
	def first(self,*args):
		"""switch to the first image"""
		self.settitle()
		self.CurIm=0
		self.ShowImage()
	def last(self,*args):
		"""switch to the last image"""
		self.settitle()
		self.CurIm=len(self.AllJpegs)-1
		self.ShowImage()
	def droite(self,*args):
		"""rotate the current image clockwise"""
		self.settitle()
		self.image.Rotate(90)
		self.ShowImage()	
	def gauche(self,*args):
		"""rotate the current image clockwise"""
		self.settitle()
		self.image.Rotate(270)
		self.ShowImage()

	def poubelle(self,*args):
		"""Send the current file to the trash"""
		self.settitle()
		if self.AllJpegs[self.CurIm] in  self.Selected:self.Selected.remove(self.AllJpegs[self.CurIm])
		self.AllJpegs.remove(self.AllJpegs[self.CurIm])
		self.image.Trash()
		self.CurIm=self.CurIm%len(self.AllJpegs)
		self.ShowImage()

	def gimp(self,*args):
		"""Edit the current file with the Gimp"""
		self.settitle()
		os.system(gimpexe+os.path.join(curdir,self.AllJpegs[self.CurIm]))

	def select(self,*args):
		"""Select or unselect the image"""
		self.settitle()
		etat=self.xml.get_widget("Selection").get_active()
		if etat and (self.AllJpegs[self.CurIm] not in self.Selected): self.Selected.append(self.AllJpegs[self.CurIm])
		if not etat and (self.AllJpegs[self.CurIm] in self.Selected): self.Selected.remove(self.AllJpegs[self.CurIm])
		

	def destroy(self,*args):
		"""destroy clicked by user"""
		self.settitle()
#		SaveSelected(self.Selected)
		sys.exit(0)

	def run(self,*args):
		"""lauch the copy of all selected files"""
		self.settitle()
#		a=time.time()
		ProcessSelected(self.Selected)
#		print "process-time = %s"%(time.time()-a)
		self.Selected=[]
		self.xml.get_widget("Selection").set_active((self.AllJpegs[self.CurIm] in self.Selected))
		print "Done"

	def die(self,*args):
		"""you wanna leave the program ??"""
		self.settitle()
		dialog = gtk.MessageDialog(None,0,gtk.MESSAGE_QUESTION,gtk.BUTTONS_OK_CANCEL,"Voulez vous vraiment quitter ce programme ?")
		result=dialog.run()
		dialog.destroy()
		if result==gtk.RESPONSE_OK: 
			SaveSelected(self.Selected)
			gtk.main_quit() #sys.exit(0)

	def SaveSelection(self,*args):
		"""Saves all the selection of photos """
		self.settitle()
		SaveSelected(self.Selected)

	def LoadSelection(self,*args):
		"""Load a previously saved  selection of photos """
		self.settitle()
		self.Selected=LoadSelected()
		for i in self.Selected:
			if not(i in self.AllJpegs): 
				self.Selected.remove(i)
		self.xml.get_widget("Selection").set_active(self.AllJpegs[self.CurIm] in  self.Selected)



	
	def SelectAll(self,*args):
		"""Select all photos for processing"""
		self.settitle()
		self.Selected=self.AllJpegs
		self.xml.get_widget("Selection").set_active(True)

	def SelectNone(self,*args):
		"""Select NO photos and empty selection"""
		self.settitle()
		self.Selected=[]
		self.xml.get_widget("Selection").set_active(False)

	def InvertSelection(self,*args):
		"""Invert the selection of photos """
		self.settitle()
		temp=self.AllJpegs[:]
		for i in self.Selected:
			temp.remove(i)
		self.Selected=temp
		self.xml.get_widget("Selection").set_active(self.AllJpegs[self.CurIm] in  self.Selected)


	def about(self,*args):
		"""display a copyright message"""	
		self.settitle()
		MessageError("Selector vous permet de mélanger, de sélectionner et de tourner \ndes photos provenant de plusieurs sources.\nÉcrit par Jérôme Kieffer <kieffer@terre-adelie.org>\nVersion 1.1a du 14/06/2005".decode("latin1"),Message=gtk.MESSAGE_INFO)
		
	
	def nextJ(self,*args):
		"""Switch to the first image of the next day"""	
		self.settitle()
		jour=os.path.dirname(self.AllJpegs[self.CurIm])
		for i in range(self.CurIm,len(self.AllJpegs)):
			jc=os.path.dirname(self.AllJpegs[i])
			if jc>jour: break
		self.CurIm=i
		self.ShowImage()	

	def previousJ(self,*args):
		"""Switch to the first image of the previous day"""	
		self.settitle()
		if self.CurIm==0: return
		jour=os.path.dirname(self.AllJpegs[self.CurIm])
		for i in range(self.CurIm-1,-1,-1):
			jc=os.path.dirname(self.AllJpegs[i])
			jd=os.path.dirname(self.AllJpegs[i-1])
			if (jc<jour) and (jd<jc): break
		self.CurIm=i
		self.ShowImage()	

	def firstJ(self,*args):
		"""switch to the first image of the first day"""
		self.settitle()
		self.CurIm=0
		self.ShowImage()
	def lastJ(self,*args):
		"""switch to the first image of the last day"""
		self.settitle()
		lastday=os.path.dirname(self.AllJpegs[-1])
		for i in range(len(self.AllJpegs)-1,-1,-1):
			jc=os.path.dirname(self.AllJpegs[i])
			jd=os.path.dirname(self.AllJpegs[i-1])
			if (jc==lastday) and (jd<jc): break
		self.CurIm=i
		self.ShowImage()	

	def firstS(self,*args):
		"""switch to the first image selected"""
		self.settitle()
		if len(self.Selected)==0:return
		self.CurIm=self.AllJpegs.index(self.Selected[0])
		self.ShowImage()
		
	def lastS(self,*args):
		"""switch to the last image selected"""
		self.settitle()
		if len(self.Selected)==0:return
		self.CurIm=self.AllJpegs.index(self.Selected[-1])
		self.ShowImage()
		
	def nextS(self,*args):
		"""switch to the next image selected"""
		self.settitle()	
		if len(self.Selected)==0:return
		for i in self.AllJpegs[self.CurIm+1:]:
			if i in self.Selected:
				self.CurIm=self.AllJpegs.index(i)
				self.ShowImage()
				return

	def previousS(self,*args):
		"""switch to the previous image selected"""
		self.settitle()	
		if len(self.Selected)==0:return
		temp=self.AllJpegs[:self.CurIm]
		temp.reverse()
		for i in temp:
			if i in self.Selected:
				self.CurIm=self.AllJpegs.index(i)
				self.ShowImage()
				return
				
	def firstNS(self,*args):
		"""switch to the first image NOT selected"""
		self.settitle()
		for i in self.AllJpegs:
			if i not in self.Selected:
				self.CurIm=self.AllJpegs.index(i)
				self.ShowImage()
				return

	def lastNS(self,*args):
		"""switch to the last image NOT selected"""
		self.settitle()
		temp=self.AllJpegs[:]
		temp.reverse()
		for i in temp:
			if i not in self.Selected:
				self.CurIm=self.AllJpegs.index(i)
				self.ShowImage()
				return
	def nextNS(self,*args):
		"""switch to the next image NOT selected"""
		self.settitle()	
		for i in self.AllJpegs[self.CurIm+1:]:
			if i not in self.Selected:
				self.CurIm=self.AllJpegs.index(i)
				self.ShowImage()
				return

	def previousNS(self,*args):
		"""switch to the previous image NOT selected"""
		self.settitle()	
		temp=self.AllJpegs[:self.CurIm]
		temp.reverse()
		for i in temp:
			if i not in self.Selected:
				self.CurIm=self.AllJpegs.index(i)
				self.ShowImage()
				return



# # # # # # fin de la classe interface graphique # # # # # #
def SaveSelected(List):
	"""save the list of selected files"""
	print "Sauvegarde de la sélection"
	os.remove(Selected_file)
	f=open(Selected_file,"w")
	for ligne in List: f.write(ligne+"\n")
	f.close()
	os.chmod(Selected_file,DefaultFileMode)


		
def LoadSelected():
	"""Load the list of selected files"""
	print "Chargement de la sélection"
	try:
		lignes=open(Selected_file,"r").readlines()
		select=[]
		for ligne in lignes :
			select.append(ligne.strip())
		return select
	except:
		return []	

def makedir(filen):
        """creates the tree structure for the file"""
        dire=os.path.dirname(filen)
        if os.path.isdir(dire):
                mkdir(filen)
        else:
                makedir(dire)
                mkdir(filen)
				
def MessageError(text,Message=gtk.MESSAGE_ERROR):
        dialog = gtk.MessageDialog(None, 0, Message,gtk.BUTTONS_OK,text)
        dialog.set_default_response(gtk.BUTTONS_OK)
        dialog.run()
        dialog.destroy()


def FindFile(RootDir):
	"""returns a list of the files with the given suffix in the given dir"""
	#files=os.system('find "%s"  -iname "*.%s"'%(RootDir,suffix)).readlines()
	files=[]
	for i in Exts:
		files+=parser().FindExts(RootDir,i)
	good=[]
	l=len(RootDir)+1
	for i in files: good.append(i.strip()[l:])
	return good







def ProcessSelected(List):
	"""copy all the selected files to "selected" subdirectory, 20 per page"""
	avcmt=SplashScreen()
	avcmt.xml.get_widget("splash").set_title("Un moment...")
	avcmt.setbar(0,"copie des fichiers existants")
	if not os.path.isdir(SelectedDir): 	mkdir(SelectedDir)
#####first of all : copy the subfolders into the day folder to help mixing the files
	for day in os.listdir(SelectedDir):
		for File in os.listdir(os.path.join(SelectedDir,day)):
			if File.find(PagePrefix)==0:
				if os.path.isdir(os.path.join(SelectedDir,day,File)):
					for ImageFile in os.listdir(os.path.join(SelectedDir,day,File)):
						src=os.path.join(SelectedDir,day,File,ImageFile)
						dst=os.path.join(SelectedDir,day,ImageFile)
						if os.path.isfile(src) and not os.path.exists(dst):
							shutil.move(src,dst)
						if (os.path.isdir(src)) and (os.path.split(src)[1] in [scaled,thumb]):
							shutil.rmtree(src)
							
#######then copy the selected files to their folders###########################		
	for File in List:
		#avcmt.setbar(float(List.index(File))/len(List),"1 -> %s"%File)
		#print float(List.index(File))/len(List)
		dest=os.path.join(SelectedDir,File)
		src=os.path.join(curdir,File)
		destdir=os.path.dirname(dest)
		if not os.path.isdir(destdir): makedir(destdir)
		if not os.path.exists(dest):
			print "copie de %s "%(File)
			shutil.copy(src,dest)
			os.chmod(dest,DefaultFileMode)
		else :
			print "%s existe déja"%(dest)
########finaly recreate the structure with pages########################
	dirs=os.listdir(SelectedDir)
	dirs.sort()
	for day in dirs:
		#avcmt.setbar(float(dirs.index(day))/len(dirs),day)
		pathday=os.path.join(SelectedDir,day)
		files=[]
		for  i in os.listdir(pathday):
			if i[-4:]==".jpg":files.append(i)
		files.sort()
		if  len(files)>NbrPerPage:
			pages=1+(len(files)-1)/NbrPerPage
			for i in range(1, pages+1):
				folder=os.path.join(pathday,PagePrefix+str(i))
				if not os.path.isdir(folder): mkdir(folder)
			for j in range(len(files)):
				i=1+(j)/NbrPerPage
				filename=os.path.join(pathday,PagePrefix+str(i),files[j])
				avcmt.setbar(float(j)/len(files),PagePrefix+str(i)+"/"+files[j])
				shutil.move(os.path.join(pathday,files[j]),filename)
				ScaleImage(filename)
		else:
			for j in files:
				avcmt.setbar(float(files.index(j))/len(files),j)
				ScaleImage(os.path.join(pathday,j))
	
	avcmt.finish()

def ScaleImage(filename):
	"""common processing for one image : create a subfolder "scaled" and "thumb" : """
	print "Génération des vignettes pour %s "%filename
	rootdir=os.path.dirname(filename)
	scaledir=os.path.join(rootdir,scaled)
	thumbdir=os.path.join(rootdir,thumb)
	if not os.path.isdir(scaledir) : mkdir(scaledir)
	if not os.path.isdir(thumbdir) : mkdir(thumbdir)
	I=photo(filename)
	I.SaveThumb(os.path.join(scaledir,os.path.basename(filename))[:-4]+"--%s.jpg"%scaled,ScaledSize,Quality=2,AllowExif=False)	
	I.SaveThumb(os.path.join(thumbdir,os.path.basename(filename))[:-4]+"--%s.jpg"%thumb,ThumbSize,Quality=1,AllowExif=False)
	
def RangeTout(RootDir):
	"""moves all the JPEG files to a directory named from their day and with the nameaccording to the time"""
	sc=SplashScreen()
	AllJpegs=FindFile(RootDir)
	AllFilesToProcess=[]
	AllreadyDone=[]
	NewFiles=[]
	for i in AllJpegs:
		if i.find(Trash)==0: continue
		if i.find(Selected)==0: continue
		try:
			a=int(i[:4])
			m=int(i[5:7])
			j=int(i[8:10])
			if (a>=0000) and (m<=12) and (j<=31) and (i[4] in ["-","_","."]) and (i[7] in ["-","_"]): 
				AllreadyDone.append(i)
			else:
				AllFilesToProcess.append(i)
		except : 
			AllFilesToProcess.append(i)
	AllFilesToProcess.sort()
	NumFiles=len(AllFilesToProcess)		
	for h in range(NumFiles):
		#a ce moment il ne reste plus que les fichiers a traiter
		i=AllFilesToProcess[h]
		sc.setbar(float(h)/NumFiles,i)
		print "%.1f %% processing  ... %s"%(100.0*h/NumFiles,i)

		data=photo(i).exif() 
		try:
			datei,heurei=data["Heure"].split()
			date=re.sub(":","-",datei)
			heurej=re.sub(":","h",heurei,1)
			model=data["Modele"].split(",")[-1]
			heure=latin1_to_ascii("%s-%s.jpg"%(re.sub(":","m",heurej,1),re.sub("/","",re.sub(" ","_",model))))
		except:
			date=time.strftime("%Y-%m-%d",time.gmtime(os.path.getctime(os.path.join(RootDir,i))))
			heure=latin1_to_ascii("%s-%s.jpg"%(time.strftime("%Hh%Mm%S",time.gmtime(os.path.getctime(os.path.join(RootDir,i)))),re.sub("/","-",re.sub(" ","_",os.path.splitext(i)[0]))))
		if not (os.path.isdir(os.path.join(RootDir,date))) : mkdir(os.path.join(RootDir,date))
		imagefile=os.path.join(RootDir,date,heure)
		ToProcess=os.path.join(date,heure)
		if os.path.isfile(imagefile):
			print "Problème ... %s existe déja "%i
			s=0
			for j in os.listdir(os.path.join(RootDir,date)):
				if j.find(heure[:-4])==0:s+=1
			ToProcess=os.path.join(date,heure[:-4]+"-%s.jpg"%s)
			imagefile=os.path.join(RootDir,ToProcess)
		shutil.move(os.path.join(RootDir,i),imagefile)
		#os.chmod(imagefile,DefaultFileMode)
		if autorotate :
			photo(imagefile).autorotate()
		AllreadyDone.append(ToProcess)
		NewFiles.append(ToProcess)
	AllreadyDone.sort()
	sc.finish()
	if len(NewFiles)>0:
		return AllreadyDone,AllreadyDone.index(NewFiles[0])
	else:
		return AllreadyDone,0




def latin1_to_ascii (unicrap):
    """This takes a UNICODE string and replaces Latin-1 characters with
        something equivalent in 7-bit ASCII. It returns a plain ASCII string. 
        This function makes a best effort to convert Latin-1 characters into 
        ASCII equivalents. It does not just strip out the Latin-1 characters.
        All characters in the standard 7-bit ASCII range are preserved. 
        In the 8th bit range all the Latin-1 accented letters are converted 
        to unaccented equivalents. Most symbol characters are converted to 
        something meaningful. Anything not converted is deleted.
    """
    xlate={0xc0:'A', 0xc1:'A', 0xc2:'A', 0xc3:'A', 0xc4:'A', 0xc5:'A',
        0xc6:'Ae', 0xc7:'C',
        0xc8:'E', 0xc9:'E', 0xca:'E', 0xcb:'E',
        0xcc:'I', 0xcd:'I', 0xce:'I', 0xcf:'I',
        0xd0:'Th', 0xd1:'N',
        0xd2:'O', 0xd3:'O', 0xd4:'O', 0xd5:'O', 0xd6:'O', 0xd8:'O',
        0xd9:'U', 0xda:'U', 0xdb:'U', 0xdc:'U',
        0xdd:'Y', 0xde:'th', 0xdf:'ss',
        0xe0:'a', 0xe1:'a', 0xe2:'a', 0xe3:'a', 0xe4:'a', 0xe5:'a',
        0xe6:'ae', 0xe7:'c',
        0xe8:'e', 0xe9:'e', 0xea:'e', 0xeb:'e',
        0xec:'i', 0xed:'i', 0xee:'i', 0xef:'i',
        0xf0:'th', 0xf1:'n',
        0xf2:'o', 0xf3:'o', 0xf4:'o', 0xf5:'o', 0xf6:'o', 0xf8:'o',
        0xf9:'u', 0xfa:'u', 0xfb:'u', 0xfc:'u',
        0xfd:'y', 0xfe:'th', 0xff:'y',
        0xa1:'!', 0xa2:'{cent}', 0xa3:'{pound}', 0xa4:'{currency}',
        0xa5:'{yen}', 0xa6:'|', 0xa7:'{section}', 0xa8:'{umlaut}',
        0xa9:'{C}', 0xaa:'{^a}', 0xab:'<<', 0xac:'{not}',
        0xad:'-', 0xae:'{R}', 0xaf:'_', 0xb0:'{degrees}',
        0xb1:'{+/-}', 0xb2:'{^2}', 0xb3:'{^3}', 0xb4:"'",
        0xb5:'{micro}', 0xb6:'{paragraph}', 0xb7:'*', 0xb8:'{cedilla}',
        0xb9:'{^1}', 0xba:'{^o}', 0xbb:'>>', 
        0xbc:'{1/4}', 0xbd:'{1/2}', 0xbe:'{3/4}', 0xbf:'?',
        0xd7:'*', 0xf7:'/'
        }

#    r = ''
    r=[]
    for i in unicrap:
        if xlate.has_key(ord(i)):
#            r += xlate[ord(i)]
	    r.append(xlate[ord(i)])
        elif ord(i) >= 0x80:
            pass
        else:
#            r += str(i)
	    r.append(str(i))
#    return r
    return "".join(r)

class parser:
	"""this class searches all the jpeg files""" 
	def __init__(self):
		self.imagelist=[]
				
	def OneDir(self,curent):
		""" append all the imagesfiles to the list, then goes recursively to the subdirectories"""
		ls=os.listdir(curent)
		subdirs=[]
		for i in ls:
			a=os.path.join(curent,i)
			if	os.path.isdir(a):
				self.OneDir(a)
			if  os.path.isfile(a):
				if i[(-len(self.suffix)):].lower()==self.suffix:
					self.imagelist.append(os.path.join(curent,i))
	def FindExts(self,root,suffix):
		self.root=root
		self.suffix=suffix
		self.OneDir(self.root)
		#print self.imagelist
		return self.imagelist






class SplashScreen:
	"""lauches a splash sceen during the processing"""
	def __init__(self):
		self.xml=gtk.glade.XML(interfaceSplash)
		self.xml.get_widget("image").set_from_pixbuf(gtk.gdk.pixbuf_new_from_file(os.path.join(installdir,"Splash.png")))
		self.pb=self.xml.get_widget("progress")
		self.xml.get_widget("splash").show()
		while gtk.events_pending():gtk.main_iteration()
	def setbar(self,val,name):
		"""set the progress-bar to the given value with the given name
		@param val: value(<1) of the progress bar
		@type val: float
		@param name: name of the current element
		@type name: string 
		@return: None"""
		self.pb.set_fraction(val)
		self.pb.set_text(name)
		while gtk.events_pending():gtk.main_iteration()
	def finish(self):
		"""destroys the interface of the splash screen"""			
		self.xml.get_widget("splash").destroy()
		while gtk.events_pending():gtk.main_iteration()		
		del self.xml
		gc.collect()



#def WARNING():
#	"""print a warning before starting the program"""	
#	txt="Selector travaille sur toutes les photos du répertoire de départ. Dans un premier temps, les photos sont renommées en fonction de leur date et de l'appareil d'origine, ce qui va les mélanger !!!\nVous avez lancé selector sur un repertoire ne ressemblant pas à une archive selector : \n %s \n \nÊtes vous sur de vouloir continuer ?"%curdir
#	dialog = gtk.MessageDialog(None,0,gtk.MESSAGE_WARNING,gtk.BUTTONS_OK_CANCEL,txt.decode("latin1"))
#	result=dialog.run()
#	dialog.destroy()
#	if result==gtk.RESPONSE_CANCEL: sys.exit(0)


class WarningSc:
	"""print a warning before starting the program and allows to chang the working directory"""
	def __init__(self,directory):
		self.directory=directory
		self.quit=True
		self.xml=gtk.glade.XML(interfaceWarning)
		self.xml.signal_connect('on_dialog_warning_destroy',self.destroy)
#		self.xml.signal_connect('on_Select_clicked',self.filer)
		self.xml.signal_connect('on_cancel_clicked',self.destroy)
		self.xml.signal_connect('on_ok_clicked',self.continu)
		self.xml.signal_connect('on_dirname_editing_done',self.continu)
		self.xml.get_widget("dirname").set_text(directory)		
		gtk.main()
	def continu(self,*args):
		"""just distroy the window and goes on ...."""
		self.directory=self.xml.get_widget("dirname").get_text().strip()
		gtk.main_quit()
		self.quit=False
		self.xml.get_widget("dialog-warning").destroy()
		while gtk.events_pending():gtk.main_iteration()
	def destroy(self,*args):
		"""destroy clicked by user -> quit the program"""
		if self.quit:
			sys.exit(0)


def mkdir(filename,mode=DefaultDirMode):
	os.mkdir(filename)
	os.chmod(filename,mode)


if __name__=='__main__':
	global curdir,Selected_file,Trashdir,SelectedDir
	curdir=False
	if len(sys.argv)>1: 
		for arg in sys.argv[1:]:
			if arg[0]=="-":
				if arg[1].lower()=="h":
					print "Selector classe des photos,\nil prend comme paramettre le chemin début de recherche et comme option:\n -nowarning : évite le message d'avertissement au lancement\n -noautorotate : ne fait pas de tests de rotation automatique, accélèrer le tri.\n"
					sys.exit(0)
				if arg.lower()=="-noautorotate":autorotate=False
				if arg.lower()=="-nowarning":StartWarning=False			
			else:
				curdir=os.path.abspath(arg)
	if curdir==False : curdir=os.getcwd()
	
	Selected_file=os.path.join(curdir,Selected_save)
	if not os.path.isfile(Selected_file):
		W=WarningSc(curdir)
		curdir=W.directory
		del W
		Selected_file=os.path.join(curdir,Selected_save)
	Trashdir=os.path.join(curdir,Trash)
	SelectedDir=os.path.join(curdir,Selected)
	
	if not os.path.isfile(Selected_file):
		f=open(Selected_file,"w")
		f.close()


	AF,first=RangeTout(curdir)
	interface(AF,first)

